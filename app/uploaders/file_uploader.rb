class FileUploader < Shrine
  plugin :backgrounding
  plugin :derivatives
  plugin :default_url
  plugin :store_dimensions

  # TODO: images returned by Shrine.remote_url have file extension set as .jpeg, not .jpg, which is annoying

  # The Cloudfront URL generated by the serverless image handler
  SERVERLESS_IMAGE_HOST = Rails.application.credentials.image_handler_host
  DEFAULT_EDITS = {
    rotate: 'auto',
    quality: 60,
    progressive: true,
    chromaSubsampling: '4:4:4',
    withoutEnlargement: true,
    sharpen: true
  }

  # Active Record - Overriding callbacks
  # https://shrinerb.com/docs/plugins/activerecord#overriding-callbacks
  class Attacher
    private

    def activerecord_after_save
      super

      if file.image? && derivatives.blank?
        AttachmentDerivativeJob.perform_later(self.class.name, self.record.class.name, self.record.id, self.name, self.file_data)
      end
    end
  end

  # Fall back to the original file URL when a derivative is missing
  # https://shrinerb.com/docs/processing#url-fallbacks
  Attacher.default_url do |derivative: nil, **|
    file&.url if derivative
  end

  # The derivatives plugin allows storing processed files ("derivatives") alongside the main attached file
  # https://shrinerb.com/docs/plugins/derivatives
  Attacher.derivatives do |original|
    def serverless_image_request(edits = {})
      request_path = Base64.strict_encode64({
        bucket: Shrine.storages[:store].bucket.name,
        key: [Shrine.storages[:store].prefix, record.attachment.id].reject(&:blank?).join('/'), # The aws object key of the original image in the `store` S3 bucket
        edits: edits
      }.to_json).chomp
      "#{SERVERLESS_IMAGE_HOST}/#{request_path}"
    end

    if file.image?
      process_derivatives(:image, original)
    else
      process_derivatives(:file, original)
    end
  end

  Attacher.derivatives :image do |original|
    {
      thumb: Shrine.remote_url( serverless_image_request({
        resize: {
          width: 200,
          height: 200,
          fit: 'cover'
        }.reverse_merge(DEFAULT_EDITS)
      })),
      small: Shrine.remote_url( serverless_image_request({
        resize: {
          width: 600,
          height: 600,
          fit: 'inside'
        }.reverse_merge(DEFAULT_EDITS)
      })),
      medium: Shrine.remote_url( serverless_image_request({
        resize: {
          width: 1200,
          height: 1200,
          fit: 'inside'
        }.reverse_merge(DEFAULT_EDITS)
      })),
      large: Shrine.remote_url( serverless_image_request({
        resize: {
          width: 2200,
          height: 2200,
          fit: 'inside'
        }.reverse_merge(DEFAULT_EDITS)
      }))
    }
  end

  Attacher.derivatives :file do |original|
    {}
  end

  Attacher.destroy_block do
    # TODO: figure out why the original upload is not being destroyed in S3
    AttachmentDestroyJob.perform_later(self.class.name, data)
  end
end
